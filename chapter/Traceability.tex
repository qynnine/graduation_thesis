\chapter{基于代码依赖紧密度分析改进需求可追踪性生成方法}

\section{引言}



\begin{algorithm}[htbp]
\caption{Establishing Initial Region}
\label{alg:EstablishingInitialRegion}
initialRegion $\leftarrow$ $\emptyset$;\\
prunedGraph $\leftarrow$ CDCGraph.setPruning($Threshold_{DC}$,$Threshold_{CD}$);\\
topLink $\leftarrow$ candidateList.next();\\
\While{prunedGraph.hasNoNeighbors(topLink.class)} {
	initialRegion.add(topLink.class);\\
	topLink $\leftarrow$ candidateList.next();
} 
initialRegion.add(topLink.class);\\
initialRegion.topIRValue $\leftarrow$ topLink.IRValue;\\
reachedClasses $\leftarrow$ $\emptyset$;\\
reachedClasses.add(prunedGraph.getTransitiveCallers(topLink.class));\\
reachedClasses.add(prunedGraph.getTransitiveCallees(topLink.class));\\
reachedClasses.add(prunedGraph.getNeighborsByData(topLink.class));\\
\ForEach {link in candidateList}
{
   	\If {reachedClasses.contains(link.class)} {
   		link.IRValue $\leftarrow$ initialRegion.topIRValue;\\
   		initialRegion.add(link.class);
   	}
}
candidateList.reorderByIRValue();\\
\end{algorithm}


\begin{algorithm}[htbp]
\caption{Re-rank Links outside Initial Region}
\label{alg:Re-rankLinksOutsideInitialRegion}
topIRValue $\leftarrow$ initialRegion.topIRValue;\\
\ForEach {link in candidateList} {
	\If {!initialRegion.contains(link.class)} {
   		\ForEach {c in initialRegion} {
        	pathList $\leftarrow$ findValidPaths(link.class, c);\\
          	$gMean$ $\leftarrow$ 0;\\
          	\ForEach {path in pathList} {
            	$gMean$ $\leftarrow$ max(GeometricMean($Closeness_{DC}$(path)), $gMean$);
          	}
          	link.IRValue $\leftarrow$ link.IRValue + $gMean$(topIRValue - link.IRValue);\\
           	\If {hasDataDependencies(c, link.class)} {
            	link.IRValue $\leftarrow$ link.IRValue + $Closeness_{CD}$(c, link.class)(topIRValue - link.IRValue);
          	}
      	}
      	\If {link.IRValue \textgreater \ topIRValue} {
       		link.IRValue $\leftarrow$ topIRValue;
        }
    }
}
candidateList.reorderByIRValue();
\end{algorithm}

\section{本章小结}

我们在本章定义了在存在~QoS~关联的场景下计算组合服务~Skyline~的问题，并给提出一种支持QoS关联的组合服务~Skyline~计算方法。我们提出了一系列剪枝规则来提高我们方法的效率。最后，我们通过一些列实验来分析我们方法的有效性以及效率。